I"R	<p>SVD(Singular value decomposition)과 pca가 기억에 남는다.<br />
SVD는 행렬 A를 U : 회전행렬, D : 대각행렬, V : 회전행렬 이 셋의 곱으로 즉 A = UDV 꼴로 분해하는 것이다. 
수학과에서 배우는 선대에선 주로 operator의 관점에서 다룰 때가 많았고 1학년 때 배운 공대생을 위한 선대 수업은 워낙 대충 들어서 
이런걸 배웠는지 잘 기억이 나지 않는다.<br />
n by n 행렬의 jordan form에 1들이 덕지덕지 붙어있던걸 생각하면 대각행렬로 분해된다는 것이 얼마나 깔끔한가. 지금 강의를 보충할 겸 
인터넷에서 적당한 numerical linear algebra 책을 보고 있는데 마침 초반에 SVD에 관한 증명이 있었다. 간략하게 적으면 A<sup>T</sup>A가 
symmetric이고 positive semi definite인 점을 이용하여 orthonormal한 eigenvector v<sub>i</sub>들을 뽑은 뒤 
AV가 UD 꼴임을 직접 보였다. 한편 컴퓨터로 분해를 구현하는건 책의 뒷부분에 나와있다고 하는데 이 과정에 A<sup>T</sup>A의 eigenvector들을 뽑는 과정이 필요한걸 
어떤식으로 회피할지 혹은 구할지 기대된다.<br />
pca는 뭘 하고자 하는지는 알겠는데 어째서 그런게 가능하게 되는지는 아직 이해가 가지 않는다. <a href="https://angeloyeo.github.io/2019/07/27/PCA.html"> 이 링크</a>의 글이 
잘 설명하고 있는 것 같아서 읽어 보고 있다.</p>

<p>그 외에 유니온파인드 알고리즘에 대해 공부하였다. 열흘 전에 <a href="https://www.acmicpc.net/problem/2463">백준 2463번</a>을 풀면서 
이런 알고리즘이 존재한다는 건 알았는데 일단 풀 당시에는 혼자서 풀어보고자 이것저것 시도해보았다. 중간에 유니온파인드의 핵심인 트리구조도 시도는 해보았으나 
O(n^2)의 벽에 부딪혀 결국 선형 자료구조를 사용해 O(nlogn)으로 풀긴 하였지만 시간은 매우 느렸다. 알고리즘을 보니 일단 트리를 합칠 때 간단하게 높이를 기준으로 
비교하여 find에 걸리는 시간을 O(logn)까지 줄일 수 있었다. 그런데 거기서 DP와 비슷한 방식으로 중복을 제거하면 유니온과 파인드가 둘다 O(1)에 되는 놀라운 결과가 나온다. 
결국 문제를 푸는데 걸리는 시간은 O(n)이면 충분하였다.</p>
:ET
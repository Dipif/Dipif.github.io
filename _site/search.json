[
  
    {
      "title"       : "TIL 8",
      "category"    : "",
      "tags"        : "Til",
      "url"         : "./2021/TIL8.markdown",
      "date"        : "2021-12-15 01:30:00 +0900",
      "description" : "",
      "content"     : "SVD(Singular value decomposition)과 pca가 기억에 남는다. SVD는 행렬 A를 U : 회전행렬, D : 대각행렬, V : 회전행렬 이 셋의 곱으로 즉 A = UDV 꼴로 분해하는 것이다. 수학과에서 배우는 선대에선 주로 operator의 관점에서 다룰 때가 많았고 1학년 때 배운 공대생을 위한 선대 수업은 워낙 대충 들어서 이런걸 배웠는지 잘 기억이 나지 않는다. n by n 행렬의 jordan form에 1들이 덕지덕지 붙어있던걸 생각하면 대각행렬로 분해된다는 것이 얼마나 깔끔한가. 지금 강의를 보충할 겸 인터넷에서 적당한 numerical linear algebra 책을 보고 있는데 마침 초반에 SVD에 관한 증명이 있었다. 간략하게 적으면 ATA가 symmetric이고 positive semi definite인 점을 이용하여 orthonormal한 eigenvector vi들을 뽑은 뒤 AV가 UD 꼴임을 직접 보였다. 한편 컴퓨터로 분해를 구현하는건 책의 뒷부분에 나와있다고 하는데 이 과정에 ATA의 eigenvector들을 뽑는 과정이 필요한걸 어떤식으로 회피할지 혹은 구할지 기대된다. pca는 뭘 하고자 하는지는 알겠는데 어째서 그런게 가능하게 되는지는 아직 이해가 가지 않는다. 이 링크의 글이 잘 설명하고 있는 것 같아서 읽어 보고 있다. 그 외에 유니온파인드 알고리즘에 대해 공부하였다. 열흘 전에 0백준 2463번을 풀면서 이런 알고리즘이 존재한다는 건 알았는데 일단 풀 당시에는 혼자서 풀어보고자 이것저것 시도해보았다. 중간에 유니온파인드의 핵심인 트리구조도 시도는 해보았으나 O(n^2)의 벽에 부딪혀 결국 선형 자료구조를 사용해 O(nlogn)으로 풀긴 하였지만 시간은 매우 느렸다. 알고리즘을 보니 일단 트리를 합칠 때 간단하게 높이를 기준으로 비교하여 find에 걸리는 시간을 O(logn)까지 줄일 수 있었다. 그런데 거기서 DP와 비슷한 방식으로 중복을 제거하면 유니온과 파인드가 둘다 O(1)에 되는 놀라운 결과가 나온다. 결국 문제를 푸는데 걸리는 시간은 O(n)이면 충분하였다."
    } ,
  
    {
      "title"       : "TIL 8",
      "category"    : "",
      "tags"        : "Til",
      "url"         : "./2021/TIL8",
      "date"        : "2021-12-15 01:30:00 +0900",
      "description" : "",
      "content"     : "SVD(Singular value decomposition)과 pca가 기억에 남는다.SVD는 행렬 A를 U : 회전행렬, D : 대각행렬, V : 회전행렬 이 셋의 곱으로 즉 A = UDV 꼴로 분해하는 것이다. 수학과에서 배우는 선대에선 주로 operator의 관점에서 다룰 때가 많았고 1학년 때 배운 공대생을 위한 선대 수업은 워낙 대충 들어서 이런걸 배웠는지 잘 기억이 나지 않는다.n by n 행렬의 jordan form에 1들이 덕지덕지 붙어있던걸 생각하면 대각행렬로 분해된다는 것이 얼마나 깔끔한가. 지금 강의를 보충할 겸 인터넷에서 적당한 numerical linear algebra 책을 보고 있는데 마침 초반에 SVD에 관한 증명이 있었다. 간략하게 적으면 ATA가 symmetric이고 positive semi definite인 점을 이용하여 orthonormal한 eigenvector vi들을 뽑은 뒤 AV가 UD 꼴임을 직접 보였다. 한편 컴퓨터로 분해를 구현하는건 책의 뒷부분에 나와있다고 하는데 이 과정에 ATA의 eigenvector들을 뽑는 과정이 필요한걸 어떤식으로 회피할지 혹은 구할지 기대된다.pca는 뭘 하고자 하는지는 알겠는데 어째서 그런게 가능하게 되는지는 아직 이해가 가지 않는다. 이 링크의 글이 잘 설명하고 있는 것 같아서 읽어 보고 있다.그 외에 유니온파인드 알고리즘에 대해 공부하였다. 열흘 전에 백준 2463번을 풀면서 이런 알고리즘이 존재한다는 건 알았는데 일단 풀 당시에는 혼자서 풀어보고자 이것저것 시도해보았다. 중간에 유니온파인드의 핵심인 트리구조도 시도는 해보았으나 O(n^2)의 벽에 부딪혀 결국 선형 자료구조를 사용해 O(nlogn)으로 풀긴 하였지만 시간은 매우 느렸다. 알고리즘을 보니 일단 트리를 합칠 때 간단하게 높이를 기준으로 비교하여 find에 걸리는 시간을 O(logn)까지 줄일 수 있었다. 그런데 거기서 DP와 비슷한 방식으로 중복을 제거하면 유니온과 파인드가 둘다 O(1)에 되는 놀라운 결과가 나온다. 결국 문제를 푸는데 걸리는 시간은 O(n)이면 충분하였다."
    } ,
  
    {
      "title"       : "TIL 7",
      "category"    : "",
      "tags"        : "Til, Algorithm, Treap",
      "url"         : "./2021/TIL7.markdown",
      "date"        : "2021-12-15 01:30:00 +0900",
      "description" : "",
      "content"     : "강의에서 선형대수를 다루다 보니 그에 관해 조금 공부를 하였다. numerical stability나 LU분해의 time complexity 등등.. 그러나 아직 원하는 만큼 정리되지 않아 다음에 올리도록 하겠다. 한편 오늘은 트립을 이해하기 위해 시간을 조금 써보았다. 종만북에 나오는 트립의 구현 그 중에서 트리 split 부분은 다음과 같다.~~~C++NodePair split(Node* root, KeyType key) { if (root == NULL) return NodePair(NULL, NULL); if (root->key right, key); root->setRight(rs.first); return NodePair(root, rs.second); } NodePair ls = split(root->left, key); root->setLeft(ls.second); return NodePair(ls.first, root);}~~~그리고 이 재귀적인 함수가 어떻게 트리를 쪼개고 합치는지 파악이 안되서 예를 들어서 직접 표현해보았다.![tree_split](/assets/img/posts/Treap_image_1.jpg)![tree_split2](/img/Treap_image_2.jpg)한 번 과정을 직접 따라가 보니 이해가 되었는데, 일단 재귀를 하면서 깊이 들어갈 때 루트를 보고 key와 비교해서 key보다 무조건 큰 트리 또는 key보다 무조건 작은 트리들을 분리해서 덜어둔다. 그리고 아직 key와의 비교가 불분명한 서브트리를 다시 들어가서 비교하고 분리하고.. 이렇게 어떤 리프 노드까지 도달한다. 그럼 이제 pair 를 리턴하면서 돌아가는데 key보다 큰 값들이 모인 서브트리의 루트를 pair.second에, 작은 값들이 모인 서브트리의 루트를 pair.first에 두면서 미리 덜어내놓았던 트리와 만났을 때 그 트리의 오른쪽이 비어있으면(작은 서브트리이므로) pair.first를 붙이고 왼쪽이 붙어있으면(큰 서브트리이므로) pair.second를 붙이면서 다시 pair를 갱신해서 리턴하고.. 이렇게 반복해서 돌아오면 우리가 원하는 treap이 완성된다. 이 과정을 insert함수까지 포함해서 코드 20줄가량으로 표현하다니 참 대단하다. 종만북에서 본 내용중 스택을 이용한 울타리자르기와 쌍벽을 이룰만큼 어려웠던 것 같다."
    } ,
  
    {
      "title"       : "TIL 7",
      "category"    : "",
      "tags"        : "Til, Algorithm, Treap",
      "url"         : "./2021/TIL7",
      "date"        : "2021-12-15 01:30:00 +0900",
      "description" : "",
      "content"     : "강의에서 선형대수를 다루다 보니 그에 관해 조금 공부를 하였다. numerical stability나 LU분해의 time complexity 등등.. 그러나 아직 원하는 만큼 정리되지 않아 다음에 올리도록 하겠다.한편 오늘은 트립을 이해하기 위해 시간을 조금 써보았다. 종만북에 나오는 트립의 구현 그 중에서 트리 split 부분은 다음과 같다.NodePair split(Node* root, KeyType key) { if (root == NULL) return NodePair(NULL, NULL); if (root-&gt;key &lt; key) { NodePair rs = split(root-&gt;right, key); root-&gt;setRight(rs.first); return NodePair(root, rs.second); } NodePair ls = split(root-&gt;left, key); root-&gt;setLeft(ls.second); return NodePair(ls.first, root);}그리고 이 재귀적인 함수가 어떻게 트리를 쪼개고 합치는지 파악이 안되서 예를 들어서 직접 표현해보았다.한 번 과정을 직접 따라가 보니 이해가 되었는데, 일단 재귀를 하면서 깊이 들어갈 때 루트를 보고 key와 비교해서 key보다 무조건 큰 트리 또는 key보다 무조건 작은 트리들을 분리해서 덜어둔다. 그리고 아직 key와의 비교가 불분명한 서브트리를 다시 들어가서 비교하고 분리하고.. 이렇게 어떤 리프 노드까지 도달한다. 그럼 이제 pair&lt;Node, Node&gt; 를 리턴하면서 돌아가는데 key보다 큰 값들이 모인 서브트리의 루트를 pair.second에, 작은 값들이 모인 서브트리의 루트를 pair.first에 두면서 미리 덜어내놓았던 트리와 만났을 때 그 트리의 오른쪽이 비어있으면(작은 서브트리이므로) pair.first를 붙이고 왼쪽이 붙어있으면(큰 서브트리이므로) pair.second를 붙이면서 다시 pair를 갱신해서 리턴하고.. 이렇게 반복해서 돌아오면 우리가 원하는 treap이 완성된다. 이 과정을 insert함수까지 포함해서 코드 20줄가량으로 표현하다니 참 대단하다. 종만북에서 본 내용중 스택을 이용한 울타리자르기와 쌍벽을 이룰만큼 어려웠던 것 같다."
    } ,
  
    {
      "title"       : "TIL 6",
      "category"    : "",
      "tags"        : "Til, Jupyter Notebook, Markdown, Numpy",
      "url"         : "./2021/TIL6.markdown",
      "date"        : "2021-12-14 00:10:00 +0900",
      "description" : "",
      "content"     : "Jupyter notebook의 기본적인 사용법을 익혔다. Jupyter notebook은 cell 단위로 실행되며 실행하는 단축키는 shift + enter 이다. esc를 누르면 해당셀의 테두리가 파랗게 되면서 명령모드로 진입하는데 이 때 할 수 있는 명령으로 다음이 있다.m : markdown 형식의 주석 입력 a(above) : 현재 셀 위에 새로운 cell 추가 b(below) : 현재 셀 아래에 새로운 cell 추가 dd(delete) : 현재 셀 삭제 한편 jupyter notebook에 작성하는 주석의 형식도 git에 작성하는 문서의 형식과 똑같은 markdown이여서 **오늘** *배운* ~~것들을~~ - Git Blog에서- 전부- 활용 가능하다!그 외에 numpy의 활용을 조금 맛보기. **numpy.array** : numpy가 가진 고유의 배열을 만들어 주며, 생성자로 리스트를 받을 수 있다. **numpy.arange** : range를 통해 만드는 리스트와 같은 numpy array를 만들어 준다. **array.shape(= numpy.shape(array))** : n차원 행렬이 a_1\\*a\\_2\\*...\\*a\\_m 형태일 때 튜플 (a\\_1, a\\_2, ..., a\\_m) 을 리턴해준다. 1*m 꼴일 땐 (m, ) 으로 리턴한다. **numpy.linalg.inv(array)** : array의 역행렬을 구해준다.**numpy.linalg.norm(array, ord)** : array 만 입력했을 땐 euclidean norm을 리턴해주는데, ord에 따라서 절대값의 합이나 가장 작은 eigen value, 일반적인 p-norm등으로 리턴해준다."
    } ,
  
    {
      "title"       : "TIL 6",
      "category"    : "",
      "tags"        : "Til, Jupyter Notebook, Markdown, Numpy",
      "url"         : "./2021/TIL6",
      "date"        : "2021-12-14 00:10:00 +0900",
      "description" : "",
      "content"     : "Jupyter notebook의 기본적인 사용법을 익혔다. Jupyter notebook은 cell 단위로 실행되며 실행하는 단축키는 shift + enter 이다. esc를 누르면 해당셀의 테두리가 파랗게 되면서 명령모드로 진입하는데 이 때 할 수 있는 명령으로 다음이 있다.m : markdown 형식의 주석 입력a(above) : 현재 셀 위에 새로운 cell 추가b(below) : 현재 셀 아래에 새로운 cell 추가dd(delete) : 현재 셀 삭제한편 jupyter notebook에 작성하는 주석의 형식도 git에 작성하는 문서의 형식과 똑같은 markdown이여서 오늘 배운 것들을 Git Blog에서 전부 활용 가능하다!그 외에 numpy의 활용을 조금 맛보기.numpy.array : numpy가 가진 고유의 배열을 만들어 주며, 생성자로 리스트를 받을 수 있다.numpy.arange : range를 통해 만드는 리스트와 같은 numpy array를 만들어 준다.array.shape(= numpy.shape(array)) : n차원 행렬이 a_1*a_2*…*a_m 형태일 때 튜플 (a_1, a_2, …, a_m) 을 리턴해준다. 1*m 꼴일 땐 (m, ) 으로 리턴한다.numpy.linalg.inv(array) : array의 역행렬을 구해준다.numpy.linalg.norm(array, ord) : array 만 입력했을 땐 euclidean norm을리턴해주는데, ord에 따라서 절대값의 합이나 가장 작은 eigen value, 일반적인 p-norm등으로 리턴해준다.** operator@(array, array) ** : 두 array의 행렬곱을 A @ B로 표현하게 해주는 연산자이다."
    } ,
  
    {
      "title"       : "TIL 5",
      "category"    : "",
      "tags"        : "Til, jekyll, blog",
      "url"         : "./2021/TIL5",
      "date"        : "2021-12-13 00:05:00 +0900",
      "description" : "",
      "content"     : "일요일이 늘 그렇듯 개인 사정으로 크게 공부는 못했으나.. 일단 오늘도 백준 2문제를 푸는 걸로 이전에 얻었던 8일 연속 문제 해결 뱃지와 동일한 기록에 도달하였다. 목표는 현재 AI 데브코스를 듣는 기간과 거의 비슷한 128일 뱃지를 얻는 것!그 외에는 이 블로그 관리를 위해 jekyll 공식 문서를 조금 읽어보았다.front matter는---layout: postread_time: true---이런 것으로 두 줄의 ‘—’ 사이에 변수이름:값 형식으로 나열하면 되는데 이는 yaml에서 사용되는 데이터 작성을 위한 포맷이라고 한다.page는 자기소개 페이지같은 곳에 사용하는데 문제는 새로운 page를 만들었을 때 메뉴에 추가하는 방법을 아직 못 찾았다. post를 좀 더 정리하기 위해서도 메뉴를 조정해야 할 것 같은데 그 방법을 소개해주는 글들과 사용하는 theme가 다르니 가리키는 위치에 필요한 파일이 없다거나 하는 경우로 무작정 따라할 수가 없다. 그게 이 문서를 읽고있는 이유기도 하다.한편 include에 대한 이해는 큰 도움이 되었다. 이 블로그의 내용이 들어있는 git 저장소에는 다양한 html 파일들이 있는데, 예를 들어 _layout 폴더의 home-page.html 파일에서 {% include search.html %} 라는 표현이 있으면 home-page layout을 사용할 때(위의 front matter 부분에 layout: home-page를 쓰면 된다.) _includes 폴더에서 search.html파일을 불러와 화면상에 표시해준다. 이걸로 post에서 필요없는 news letter를 드디어 삭제할 수 있었다."
    } ,
  
    {
      "title"       : "TIL 4",
      "category"    : "",
      "tags"        : "Til",
      "url"         : "./2021/TIL4",
      "date"        : "2021-12-12 00:25:00 +0900",
      "description" : "",
      "content"     : "종만북을 보면서 알고리즘 공부를 하였다.balanced tree중 구현하기 쉽다는 트립과 세그먼트 트리, 그리고 펜윅 트리를 배웠다.트립은 노드를 좌우로 크기에 따라 정렬하는 것 뿐만이 아니라 각 노드에 난수로 우선순위를 부여하여 위에서 아래로 그 우선순위에 따라서 또 배열한다. 소수 판별에 난수를 사용하는 알고리즘을 본 적은 있지만자료구조에 난수라니 대단한 아이디어다.그런데 이게 노드를 추가하고 삭제하는 과정이 영 이해가 안가서.. 추후에 더 이해한 후에 따로 포스트를 해 봐야겠다.세그먼트 트리는 어떤 배열이 있을 때 그 구간을 반으로 쪼개서 좌우 자식노드로 붙이고 다시 반쪽 구간들을 반토막 내서자식의 자식으로 붙이고.. 이렇게 해서 log n 높이의 트리를 만드는 것이다. 그리고 구하고자 하는 값을 트리의 노드들이 나타내는구간들에 대해 미리 구해놓고, 임의의 [a:b]에 대해 그 구간들을 합병하여 결과값을 구한다. 이 방법의 장점으로는 한번 트리의 노드들에 값을구해 놓으면 여러 [a:b]들에 대해 O(log n)의 시간으로 결과값을 구하게 해준다는 점이 있고, 배열에 어떤 값이 변하더라도 그 변화를결과에 반영하는데 O(log n)의 시간밖에 걸리지 않는 다는 점 또한 있다.펜윅 트리는 세그먼트 트리의 특수한 형태인데, 세그먼트 트리를 사용해 구간합을 구하기 위해 필요없는 정보는 전부 삭제한 것이다. 그런데 그 형태가 어찌나 정교한지, 비트마스킹으로 인덱스를 옮겨다니는건 기가 막힌다. 구간합을 구하는 건 그냥 부분합을 구하는걸로 충분하지 않은가 생각할 수 있지만, 펜윅 트리도 세그먼트 트리와 마찬가지로 배열의 값이 변경됐을 때 그걸 반영하는데 O(log n)의 시간밖에 걸리지 않는다는 장점이 있다."
    } ,
  
    {
      "title"       : "TIL 3",
      "category"    : "",
      "tags"        : "Til",
      "url"         : "./2021/TIL3",
      "date"        : "2021-12-11 01:35:00 +0900",
      "description" : "",
      "content"     : "오늘 강의에서 dfs를 stack을 이용해서 구현하는 걸 보았다. 정점 탐색이 아니라 간선 탐색이라 조금은 다르긴 하겠지만 일반적인 dfs의 경우에도 비슷하게 구현할 수 있을 것이다. 사실 함수 호출이 다 스택 영역에서 이루어 지는 만큼 그를 응용하면구현할 수 있는 건 당연하겠지만, 생각했던 것보다 훨씬 간단해서 알아두면 활용할 데가 많을 것 같았다. 안그래도 개인적으로 재귀에 대해 구현은 보기 좋으나 비효율적인 면이 있어 싫어하는데 앞으로 재귀 문제에선 전부 stack구현을 시도해봐야겠다.한편 이번 강의에서 하필 stack을 사용한 이유는 정점의 갯수가 최대 1만개까지 가기 때문으로 보인다.파이썬은 재귀 횟수에 1000의 제한이 있고, C++은 Visual studio 기준으로 1mb의 stack memory 제한이 있다.이를 해제하는 방법은 있으나, 제한에는 나름의 이유가 있을 것이다. 이에 관한 내용을 다음 스택 오버플로우 링크 에서 확인할 수 있었다.첫번째 답변에선 “32bit 프로그램은 2gb의 가상공간을 가질 수 있고 이 때 stack size가 2mb라면 1024개의 threads를 가질 수있다(각 thread는 thread stack이라고 부르는 고유의 stack을 가진다고 한다). web server 같은 경우엔 stack size를100mb까지 늘리고 20개의 thread만 가져도 충분할 수 있지만, 아주 간단한 gui 프로그램이라도 이는 부족하다” 고 하였으며두번째 답변에선 “C 또는 C++에서 stack overflow가 일어나는 경우는 거의 에러가 원인이기 때문에, 제한된 stack size는 에러 감지 및 방지를 위해 사용된다” 고 하였다.둘 다 꽤나 역사가 담긴 답변이다."
    } ,
  
    {
      "title"       : "TIL 2",
      "category"    : "",
      "tags"        : "Til, Git",
      "url"         : "./2021/TIL2",
      "date"        : "2021-12-09 23:55:00 +0900",
      "description" : "",
      "content"     : "어제 열심히 cmp_to_key로 구현했던 문제가 공교롭게도 오늘 강의에서 다루어졌다.강의에선 깔끔한 방법으로 key를 만들어 구현해냈는데, 거기서 한 문자열을 여러번 반복해서 비교하는 테크닉을 사용하였다.원형 문자열에 관한 문제를 풀 때도 그렇고 종종 쓰이는 듯 하다.오늘도 Git에 대해 조금 더 공부하였는데 merge와 branch에 대해 알게 되었다. 한 branch에서 막 문서를 수정하고 다른 branch로 이동하니까 그 문서가 이전 상태 그대로 돌아가있는게 충격적이였다.간단하게 정리해보면cd [경로] : 기준 폴더를 이동할 때 쓴다.git init : 로컬 저장소 초기화git add [파일이름 또는 경로] : 해당 파일을 인덱스에 등록. 경로내 모든파일을 add하고싶을 땐 이름 대신 ./ 을 쓰면 된다.git commit -m “메세지” : 인덱스에 등록된 변경사항을 바탕으로 현재 진행 상태를 로컬 저장소에 저장.git push [url] [branch] : 원격 저장소의 해당 branch에 지금까지 commit한 것들을 반영한다.git pull [url] [branch] : 원격 저장소의 해당 branch의 내용을 로컬 저장소로 가져온다.git status : 말 그대로 상태를 보여준다.git log (–graph) (–oneline) : 지금까지 commit 한 log들을 보여준다. 괄호안의 내용을 입력하면 간단하게 나온다.git branch : branch들을 보여준다.git branch (-d) [branch 이름] : branch를 만든다. -d를 입력하면 삭제한다.git checkout (-b) [branch 이름] : branch로 이동한다. -b를 입력하면 그 branch를 생성하며 이동한다.git merge [branch 이름] : branch를 합친다. 충돌이 발생하면 수동으로 해결해야 한다.이 정도인 것 같다. 일단 혼자서 가지고 놀만큼의 기초는 뗀 것 같고 마침 슬랙에서 한 분이 Git 공부에 관한 조언을 해 주셔서 그 부분을 봐야겠다."
    } ,
  
    {
      "title"       : "Github Blog 첫 글",
      "category"    : "",
      "tags"        : "",
      "url"         : "./2021/Github-Blog-%EC%B2%AB-%EA%B8%80",
      "date"        : "2021-12-08 20:10:00 +0900",
      "description" : "",
      "content"     : "블로그 같은건 처음 해보는데 Github로 시작하려니 어려운 점이 많네요."
    } ,
  
    {
      "title"       : "TIL 1",
      "category"    : "",
      "tags"        : "",
      "url"         : "./2021/TIL1",
      "date"        : "2021-12-08 20:10:00 +0900",
      "description" : "",
      "content"     : "어제 오늘 동안 데브코스 강좌의 내용과 더불어 Git의 사용법에 대해 공부하였다.이제 Git에서 뭔가 기여할 때 clone 해와서 수정하고 add, commit 과정을 거쳐 push까지 하면 되는 건 알았다.강의에선 이미 알고 있던 자료구조에 대한 내용을 아주 빠르게 진행하고 있어서 복습하는 기분으로 보고 있다.도중에 나온 실습 문제에서 Python의 sort만으로 풀기엔 key parameter를 정하기 곤란한 문제가 있었다.C++이면 그냥 compare 함수를 만들어서 풀었을텐데 싶어서 찾아보니 python에도 비슷한 기능을 하는 함수가 있었다.functools 모듈의 cmp_to_key 라는 함수인데 원하는 방식으로 크기를 비교하여 그 결과를 음수, 0, 양수로 리턴하면 되는 것이다.예를 들면from functools import cmp_to_keydef cmp(a, b) : if a &gt; b : return 1 elif a &lt; b : return -1 return 0 l = [3, 1, 2]l.sort(key = cmp_to_key(cmp))이와 같이 쓰면 리스트 l 을 [1, 2, 3]으로 정렬해 준다."
    } 
  
]

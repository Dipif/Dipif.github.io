[
  
    {
      "title"       : "TIL 4",
      "category"    : "",
      "tags"        : "Til",
      "url"         : "./TIL4.html",
      "date"        : "2021-12-12 00:25:00 +0900",
      "description" : "",
      "content"     : "종만북을 보면서 알고리즘 공부를 하였다.balanced tree중 구현하기 쉽다는 트립과 세그먼트 트리, 그리고 펜윅 트리를 배웠다.트립은 노드를 좌우로 크기에 따라 정렬하는 것 뿐만이 아니라 각 노드에 난수로 우선순위를 부여하여 위에서 아래로 그 우선순위에 따라서 또 배열한다. 소수 판별에 난수를 사용하는 알고리즘을 본 적은 있지만자료구조에 난수라니 대단한 아이디어다.그런데 이게 노드를 추가하고 삭제하는 과정이 영 이해가 안가서.. 추후에 더 이해한 후에 따로 포스트를 해 봐야겠다.세그먼트 트리는 어떤 배열이 있을 때 그 구간을 반으로 쪼개서 좌우 자식노드로 붙이고 다시 반쪽 구간들을 반토막 내서자식의 자식으로 붙이고.. 이렇게 해서 log n 높이의 트리를 만드는 것이다. 그리고 구하고자 하는 값을 트리의 노드들이 나타내는구간들에 대해 미리 구해놓고, 임의의 [a:b]에 대해 그 구간들을 합병하여 결과값을 구한다. 이 방법의 장점으로는 한번 트리의 노드들에 값을구해 놓으면 여러 [a:b]들에 대해 O(log n)의 시간으로 결과값을 구하게 해준다는 점이 있고, 배열에 어떤 값이 변하더라도 그 변화를결과에 반영하는데 O(log n)의 시간밖에 걸리지 않는 다는 점 또한 있다.펜윅 트리는 세그먼트 트리의 특수한 형태인데, 세그먼트 트리를 사용해 구간합을 구하기 위해 필요없는 정보는 전부 삭제한 것이다. 그런데 그 형태가 어찌나 정교한지, 비트마스킹으로 인덱스를 옮겨다니는건 기가 막힌다. 구간합을 구하는 건 그냥 부분합을 구하는걸로 충분하지 않은가 생각할 수 있지만, 펜윅 트리도 세그먼트 트리와 마찬가지로 배열의 값이 변경됐을 때 그걸 반영하는데 O(log n)의 시간밖에 걸리지 않는다는 장점이 있다."
    } ,
  
    {
      "title"       : "TIL 3",
      "category"    : "",
      "tags"        : "Til",
      "url"         : "./TIL3.html",
      "date"        : "2021-12-11 01:35:00 +0900",
      "description" : "",
      "content"     : "오늘 강의에서 dfs를 stack을 이용해서 구현하는 걸 보았다. 정점 탐색이 아니라 간선 탐색이라 조금은 다르긴 하겠지만 일반적인 dfs의 경우에도 비슷하게 구현할 수 있을 것이다. 사실 함수 호출이 다 스택 영역에서 이루어 지는 만큼 그를 응용하면구현할 수 있는 건 당연하겠지만, 생각했던 것보다 훨씬 간단해서 알아두면 활용할 데가 많을 것 같았다. 안그래도 개인적으로 재귀에 대해 구현은 보기 좋으나 비효율적인 면이 있어 싫어하는데 앞으로 재귀 문제에선 전부 stack구현을 시도해봐야겠다.한편 이번 강의에서 하필 stack을 사용한 이유는 정점의 갯수가 최대 1만개까지 가기 때문으로 보인다.파이썬은 재귀 횟수에 1000의 제한이 있고, C++은 Visual studio 기준으로 1mb의 stack memory 제한이 있다.이를 해제하는 방법은 있으나, 제한에는 나름의 이유가 있을 것이다. 이에 관한 내용을 다음 스택 오버플로우 링크 에서 확인할 수 있었다.첫번째 답변에선 “32bit 프로그램은 2gb의 가상공간을 가질 수 있고 이 때 stack size가 2mb라면 1024개의 threads를 가질 수있다(각 thread는 thread stack이라고 부르는 고유의 stack을 가진다고 한다). web server 같은 경우엔 stack size를100mb까지 늘리고 20개의 thread만 가져도 충분할 수 있지만, 아주 간단한 gui 프로그램이라도 이는 부족하다” 고 하였으며두번째 답변에선 “C 또는 C++에서 stack overflow가 일어나는 경우는 거의 에러가 원인이기 때문에, 제한된 stack size는 에러 감지 및 방지를 위해 사용된다” 고 하였다.둘 다 꽤나 역사가 담긴 답변이다."
    } ,
  
    {
      "title"       : "TIL 2",
      "category"    : "",
      "tags"        : "Til, Git",
      "url"         : "./TIL2.html",
      "date"        : "2021-12-09 23:55:00 +0900",
      "description" : "",
      "content"     : "어제 열심히 cmp_to_key로 구현했던 문제가 공교롭게도 오늘 강의에서 다루어졌다.강의에선 깔끔한 방법으로 key를 만들어 구현해냈는데, 거기서 한 문자열을 여러번 반복해서 비교하는 테크닉을 사용하였다.원형 문자열에 관한 문제를 풀 때도 그렇고 종종 쓰이는 듯 하다.오늘도 Git에 대해 조금 더 공부하였는데 merge와 branch에 대해 알게 되었다. 한 branch에서 막 문서를 수정하고 다른 branch로 이동하니까 그 문서가 이전 상태 그대로 돌아가있는게 충격적이였다.간단하게 정리해보면cd [경로] : 기준 폴더를 이동할 때 쓴다.git init : 로컬 저장소 초기화git add [파일이름 또는 경로] : 해당 파일을 인덱스에 등록. 경로내 모든파일을 add하고싶을 땐 이름 대신 ./ 을 쓰면 된다.git commit -m “메세지” : 인덱스에 등록된 변경사항을 바탕으로 현재 진행 상태를 로컬 저장소에 저장.git push [url] [branch] : 원격 저장소의 해당 branch에 지금까지 commit한 것들을 반영한다.git pull [url] [branch] : 원격 저장소의 해당 branch의 내용을 로컬 저장소로 가져온다.git status : 말 그대로 상태를 보여준다.git log (–graph) (–oneline) : 지금까지 commit 한 log들을 보여준다. 괄호안의 내용을 입력하면 간단하게 나온다.git branch : branch들을 보여준다.git branch (-d) [branch 이름] : branch를 만든다. -d를 입력하면 삭제한다.git checkout (-b) [branch 이름] : branch로 이동한다. -b를 입력하면 그 branch를 생성하며 이동한다.git merge [branch 이름] : branch를 합친다. 충돌이 발생하면 수동으로 해결해야 한다.이 정도인 것 같다. 일단 혼자서 가지고 놀만큼의 기초는 뗀 것 같고 마침 슬랙에서 한 분이 Git 공부에 관한 조언을 해 주셔서 그 부분을 봐야겠다."
    } ,
  
    {
      "title"       : "Github Blog 첫 글",
      "category"    : "",
      "tags"        : "",
      "url"         : "./Github-Blog-%EC%B2%AB-%EA%B8%80.html",
      "date"        : "2021-12-08 20:10:00 +0900",
      "description" : "",
      "content"     : "블로그 같은건 처음 해보는데 Github로 시작하려니 어려운 점이 많네요."
    } ,
  
    {
      "title"       : "TIL 1",
      "category"    : "",
      "tags"        : "",
      "url"         : "./TIL1.html",
      "date"        : "2021-12-08 20:10:00 +0900",
      "description" : "",
      "content"     : "어제 오늘 동안 데브코스 강좌의 내용과 더불어 Git의 사용법에 대해 공부하였다.이제 Git에서 뭔가 기여할 때 clone 해와서 수정하고 add, commit 과정을 거쳐 push까지 하면 되는 건 알았다.강의에선 이미 알고 있던 자료구조에 대한 내용을 아주 빠르게 진행하고 있어서 복습하는 기분으로 보고 있다.도중에 나온 실습 문제에서 Python의 sort만으로 풀기엔 key parameter를 정하기 곤란한 문제가 있었다.C++이면 그냥 compare 함수를 만들어서 풀었을텐데 싶어서 찾아보니 python에도 비슷한 기능을 하는 함수가 있었다.functools 모듈의 cmp_to_key 라는 함수인데 원하는 방식으로 크기를 비교하여 그 결과를 음수, 0, 양수로 리턴하면 되는 것이다.예를 들면from functools import cmp_to_keydef cmp(a, b) : if a &gt; b : return 1 elif a &lt; b : return -1 return 0 l = [3, 1, 2]l.sort(key = cmp_to_key(cmp))이와 같이 쓰면 리스트 l 을 [1, 2, 3]으로 정렬해 준다."
    } 
  
]

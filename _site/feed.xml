<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-12-21T01:31:49+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hello</title><subtitle>for record</subtitle><author><name>이대겸</name></author><entry><title type="html">TIL 9</title><link href="http://localhost:4000/2021/TIL9" rel="alternate" type="text/html" title="TIL 9" /><published>2021-12-20T23:00:00+09:00</published><updated>2021-12-20T23:00:00+09:00</updated><id>http://localhost:4000/2021/TIL9</id><content type="html" xml:base="http://localhost:4000/2021/TIL9">&lt;p&gt;지난주 금요일에 강의를 듣는데, 반 정도 듣자마자 전혀 머릿속에 안들어오기 시작했다. 수학과지만 통계는 고등학교 이후로 잡은 적이 없다보니 하나도 아는게 없어서 
내용이 이해가 안갔다. 이틀간 introduction, statistics가 들어간 책들을 살펴봤지만 소득이 없었는데 코세라에 검색해서 나온 &lt;a href=&quot;https://www.coursera.org/learn/stanford-statistics/home/welcome&quot;&gt; 이 강의 &lt;/a&gt;가 아주 마음에 들었다. 
지금 데브코스에서 듣는 강의와 다루는 내용도 비슷하고 내용은 두배 정도 늘려놔서 이해하기 더 좋았다.&lt;/p&gt;

&lt;p&gt;오늘 진행된 라이브세션은 꽤 재미있었다. 나동빈 강사님이 진행하셨는데 검색해보니 꽤 많은 자료가 나오는 유명인이셨다. Adversarial attack에 대해 강의하셨다.&lt;br /&gt;
Adversarial attack이란 딥러닝으로 학습된 모델을 대상으로 기존의 데이터와 아주 살짝 비뀐 데이터를 넣어 완전히 다른 결과가 나오게 유도하는 것을 말한다.&lt;br /&gt;
그 방식으로 약한 노이즈를 주거나, 모양은 그대로 두면서 텍스쳐를 바꾸거나, 한 글자만 바꾸는 등의 다양한 방법이 있었다. 
그럼 그 노이즈 같은걸 어떻게 세팅할까? 하는 부분은 화이트박스 공격과 블랙박스 공격 두가지로 나뉘어진다.&lt;br /&gt;
화이트박스 공격은 일반적으로 신경망이 학습하는 방식(경사하강법)을 반대로 사용하여 데이터를 아주 조금씩 변경하여 원하는 결과로 유도한다.&lt;br /&gt;
블랙박스 공격은 두 가지 방법이 인상깊었는데 하나는 공격 목표인 모델과 비슷한 기능을 수행하는 모델을 직접 구현한 뒤, 그 모델에 대해 화이트박스 공격을 하고 그 데이터를 원래의 공격 목표에 적용하는 것이다. 이게 된다고 한다. 두번째로 
구역 A에 속한 데이터 a와 구역 B에 속한 데이터 b가 있으면 a를 조금씩 변형하고 b에 projection하는 것을 여러 방향으로 여러 번 시도하면 총 1만번 가량의 공격 시도로 목표를 달성할 수 있다고 한다.&lt;br /&gt;
마지막으로 가장 인상깊었던 부분은 왜 adversarial attack이 가능한가? 하는 부분이였다. 특히 해당 원인을 robust와 non-robust로 나누었는데 robust는 일반적으로 인간이 인지 가능한 특징, non-robust는 인간이 보기엔 노이즈같은 특징들을 의미한다. 
그리고 adversarial attack은 non-robust쪽에 혼란을 줌으로써 정확도를 떨어트린다. 내가 이 부분이 인상깊은 이유 두가지가 있다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;기계는 인간이 인지 못하는 non-robust 정보들을 굉장히 중요하게 사용하고 있다. 따라서 기계가 완전히 새로운 지식을 만들어 낼 수 있을 거라 기대된다.&lt;/li&gt;
  &lt;li&gt;한편 기계는 인간이 주로 사용하는 robust 정보만으론 아직 충분한 정확도를 얻을 수 없다. 따라서 기계는 여전히 발전할 여지가 많이 남아 있다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;조금씩 막히는 부분이 생기면서 진도가 느려지고 있다. 공부해야할게 많다.&lt;/p&gt;</content><author><name>이대겸</name></author><category term="Til" /><summary type="html">지난주 금요일에 강의를 듣는데, 반 정도 듣자마자 전혀 머릿속에 안들어오기 시작했다. 수학과지만 통계는 고등학교 이후로 잡은 적이 없다보니 하나도 아는게 없어서 내용이 이해가 안갔다. 이틀간 introduction, statistics가 들어간 책들을 살펴봤지만 소득이 없었는데 코세라에 검색해서 나온 이 강의 가 아주 마음에 들었다. 지금 데브코스에서 듣는 강의와 다루는 내용도 비슷하고 내용은 두배 정도 늘려놔서 이해하기 더 좋았다.</summary></entry><entry><title type="html">TIL 7</title><link href="http://localhost:4000/2021/TIL7" rel="alternate" type="text/html" title="TIL 7" /><published>2021-12-15T01:30:00+09:00</published><updated>2021-12-15T01:30:00+09:00</updated><id>http://localhost:4000/2021/TIL7</id><content type="html" xml:base="http://localhost:4000/2021/TIL7">&lt;p&gt;강의에서 선형대수를 다루다 보니 그에 관해 조금 공부를 하였다. numerical stability나 LU분해의 time complexity 등등.. 
그러나 아직 원하는 만큼 정리되지 않아 다음에 올리도록 하겠다.&lt;/p&gt;

&lt;p&gt;한편 오늘은 트립을 이해하기 위해 시간을 조금 써보았다. 종만북에 나오는 트립의 구현 그 중에서 트리 split 부분은 다음과 같다.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C++&quot;&gt;NodePair split(Node* root, KeyType key) {
	if (root == NULL) return NodePair(NULL, NULL);
	if (root-&amp;gt;key &amp;lt; key) {
		NodePair rs = split(root-&amp;gt;right, key);
		root-&amp;gt;setRight(rs.first);
		return NodePair(root, rs.second);
	}
	NodePair ls = split(root-&amp;gt;left, key);
	root-&amp;gt;setLeft(ls.second);
	return NodePair(ls.first, root);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;그리고 이 재귀적인 함수가 어떻게 트리를 쪼개고 합치는지 파악이 안되서 예를 들어서 직접 표현해보았다.
&lt;img src=&quot;/assets/img/posts/Treap_image_1.jpg&quot; alt=&quot;tree_split&quot; /&gt;
&lt;img src=&quot;/assets/img/posts/Treap_image_2.jpg&quot; alt=&quot;tree_split2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;한 번 과정을 직접 따라가 보니 이해가 되었는데, 일단 재귀를 하면서 깊이 들어갈 때 루트를 보고 key와 비교해서 key보다 무조건 큰 트리 또는 
key보다 무조건 작은 트리들을 분리해서 덜어둔다. 그리고 아직 key와의 비교가 불분명한 서브트리를 다시 들어가서 비교하고 분리하고.. 이렇게 어떤 리프 노드까지 도달한다. 
그럼 이제 pair&amp;lt;Node, Node&amp;gt; 를 리턴하면서 돌아가는데 key보다 큰 값들이 모인 서브트리의 루트를 pair.second에, 작은 값들이 모인 서브트리의 루트를 
pair.first에 두면서 미리 덜어내놓았던 트리와 만났을 때 그 트리의 오른쪽이 비어있으면(작은 서브트리이므로) pair.first를 붙이고 왼쪽이 붙어있으면(큰 서브트리이므로) pair.second를 붙이면서 
다시 pair를 갱신해서 리턴하고.. 이렇게 반복해서 돌아오면 우리가 원하는 treap이 완성된다. 이 과정을 insert함수까지 포함해서 코드 20줄가량으로 표현하다니 참 대단하다. 
종만북에서 본 내용중 스택을 이용한 울타리자르기와 쌍벽을 이룰만큼 어려웠던 것 같다.&lt;/p&gt;</content><author><name>이대겸</name></author><category term="Til" /><category term="Algorithm" /><category term="Treap" /><summary type="html">강의에서 선형대수를 다루다 보니 그에 관해 조금 공부를 하였다. numerical stability나 LU분해의 time complexity 등등.. 그러나 아직 원하는 만큼 정리되지 않아 다음에 올리도록 하겠다.</summary></entry><entry><title type="html">TIL 8</title><link href="http://localhost:4000/2021/TIL9-%EB%B3%B5%EC%82%AC%EB%B3%B8.markdown" rel="alternate" type="text/html" title="TIL 8" /><published>2021-12-15T01:30:00+09:00</published><updated>2021-12-15T01:30:00+09:00</updated><id>http://localhost:4000/2021/TIL9%20-%20%EB%B3%B5%EC%82%AC%EB%B3%B8.markdown</id><content type="html" xml:base="http://localhost:4000/2021/TIL9-%EB%B3%B5%EC%82%AC%EB%B3%B8.markdown">SVD(Singular value decomposition)과 pca가 기억에 남는다.  
SVD는 행렬 A를 U : 회전행렬, D : 대각행렬, V : 회전행렬 이 셋의 곱으로 즉 A = UDV 꼴로 분해하는 것이다. 
수학과에서 배우는 선대에선 주로 operator의 관점에서 다룰 때가 많았고 1학년 때 배운 공대생을 위한 선대 수업은 워낙 대충 들어서 
이런걸 배웠는지 잘 기억이 나지 않는다.  
n by n 행렬의 jordan form에 1들이 덕지덕지 붙어있던걸 생각하면 대각행렬로 분해된다는 것이 얼마나 깔끔한가. 지금 강의를 보충할 겸 
인터넷에서 적당한 numerical linear algebra 책을 보고 있는데 마침 초반에 SVD에 관한 증명이 있었다. 간략하게 적으면 A&lt;sup&gt;T&lt;/sup&gt;A가 
symmetric이고 positive semi definite인 점을 이용하여 orthonormal한 eigenvector v&lt;sub&gt;i&lt;/sub&gt;들을 뽑은 뒤 
AV가 UD 꼴임을 직접 보였다. 한편 컴퓨터로 분해를 구현하는건 책의 뒷부분에 나와있다고 하는데 이 과정에 A&lt;sup&gt;T&lt;/sup&gt;A의 eigenvector들을 뽑는 과정이 필요한걸 
어떤식으로 회피할지 혹은 구할지 기대된다.  
pca는 뭘 하고자 하는지는 알겠는데 어째서 그런게 가능하게 되는지는 아직 이해가 가지 않는다. &lt;A href = &quot;https://angeloyeo.github.io/2019/07/27/PCA.html&quot;&gt; 이 링크&lt;/A&gt;의 글이 
잘 설명하고 있는 것 같아서 읽어 보고 있다. 

그 외에 유니온파인드 알고리즘에 대해 공부하였다. 열흘 전에 &lt;A href = &quot;https://www.acmicpc.net/problem/2463&quot;&gt;백준 2463번&lt;/A&gt;을 풀면서 
이런 알고리즘이 존재한다는 건 알았는데 일단 풀 당시에는 혼자서 풀어보고자 이것저것 시도해보았다. 중간에 유니온파인드의 핵심인 트리구조도 시도는 해보았으나 
O(n^2)의 벽에 부딪혀 결국 선형 자료구조를 사용해 O(nlogn)으로 풀긴 하였지만 시간은 매우 느렸다. 알고리즘을 보니 일단 트리를 합칠 때 간단하게 높이를 기준으로 
비교하여 find에 걸리는 시간을 O(logn)까지 줄일 수 있었다. 그런데 거기서 DP와 비슷한 방식으로 중복을 제거하면 유니온과 파인드가 둘다 O(1)에 되는 놀라운 결과가 나온다. 
결국 문제를 푸는데 걸리는 시간은 O(n)이면 충분하였다.</content><author><name>이대겸</name></author><category term="Til" /><summary type="html">SVD(Singular value decomposition)과 pca가 기억에 남는다. SVD는 행렬 A를 U : 회전행렬, D : 대각행렬, V : 회전행렬 이 셋의 곱으로 즉 A = UDV 꼴로 분해하는 것이다. 수학과에서 배우는 선대에선 주로 operator의 관점에서 다룰 때가 많았고 1학년 때 배운 공대생을 위한 선대 수업은 워낙 대충 들어서 이런걸 배웠는지 잘 기억이 나지 않는다. n by n 행렬의 jordan form에 1들이 덕지덕지 붙어있던걸 생각하면 대각행렬로 분해된다는 것이 얼마나 깔끔한가. 지금 강의를 보충할 겸 인터넷에서 적당한 numerical linear algebra 책을 보고 있는데 마침 초반에 SVD에 관한 증명이 있었다. 간략하게 적으면 ATA가 symmetric이고 positive semi definite인 점을 이용하여 orthonormal한 eigenvector vi들을 뽑은 뒤 AV가 UD 꼴임을 직접 보였다. 한편 컴퓨터로 분해를 구현하는건 책의 뒷부분에 나와있다고 하는데 이 과정에 ATA의 eigenvector들을 뽑는 과정이 필요한걸 어떤식으로 회피할지 혹은 구할지 기대된다. pca는 뭘 하고자 하는지는 알겠는데 어째서 그런게 가능하게 되는지는 아직 이해가 가지 않는다. 이 링크의 글이 잘 설명하고 있는 것 같아서 읽어 보고 있다.</summary></entry><entry><title type="html">TIL 8</title><link href="http://localhost:4000/2021/TIL8.markdown" rel="alternate" type="text/html" title="TIL 8" /><published>2021-12-15T01:30:00+09:00</published><updated>2021-12-15T01:30:00+09:00</updated><id>http://localhost:4000/2021/TIL8.markdown</id><content type="html" xml:base="http://localhost:4000/2021/TIL8.markdown">SVD(Singular value decomposition)과 pca가 기억에 남는다.  
SVD는 행렬 A를 U : 회전행렬, D : 대각행렬, V : 회전행렬 이 셋의 곱으로 즉 A = UDV 꼴로 분해하는 것이다. 
수학과에서 배우는 선대에선 주로 operator의 관점에서 다룰 때가 많았고 1학년 때 배운 공대생을 위한 선대 수업은 워낙 대충 들어서 
이런걸 배웠는지 잘 기억이 나지 않는다.  
n by n 행렬의 jordan form에 1들이 덕지덕지 붙어있던걸 생각하면 대각행렬로 분해된다는 것이 얼마나 깔끔한가. 지금 강의를 보충할 겸 
인터넷에서 적당한 numerical linear algebra 책을 보고 있는데 마침 초반에 SVD에 관한 증명이 있었다. 간략하게 적으면 A&lt;sup&gt;T&lt;/sup&gt;A가 
symmetric이고 positive semi definite인 점을 이용하여 orthonormal한 eigenvector v&lt;sub&gt;i&lt;/sub&gt;들을 뽑은 뒤 
AV가 UD 꼴임을 직접 보였다. 한편 컴퓨터로 분해를 구현하는건 책의 뒷부분에 나와있다고 하는데 이 과정에 A&lt;sup&gt;T&lt;/sup&gt;A의 eigenvector들을 뽑는 과정이 필요한걸 
어떤식으로 회피할지 혹은 구할지 기대된다.  
pca는 뭘 하고자 하는지는 알겠는데 어째서 그런게 가능하게 되는지는 아직 이해가 가지 않는다. &lt;A href = &quot;https://angeloyeo.github.io/2019/07/27/PCA.html&quot;&gt; 이 링크&lt;/A&gt;의 글이 
잘 설명하고 있는 것 같아서 읽어 보고 있다. 

그 외에 유니온파인드 알고리즘에 대해 공부하였다. 열흘 전에 &lt;A href = &quot;https://www.acmicpc.net/problem/2463&quot;&gt;0백준 2463번&lt;A&gt;을 풀면서 
이런 알고리즘이 존재한다는 건 알았는데 일단 풀 당시에는 혼자서 풀어보고자 이것저것 시도해보았다. 중간에 유니온파인드의 핵심인 트리구조도 시도는 해보았으나 
O(n^2)의 벽에 부딪혀 결국 선형 자료구조를 사용해 O(nlogn)으로 풀긴 하였지만 시간은 매우 느렸다. 알고리즘을 보니 일단 트리를 합칠 때 간단하게 높이를 기준으로 
비교하여 find에 걸리는 시간을 O(logn)까지 줄일 수 있었다. 그런데 거기서 DP와 비슷한 방식으로 중복을 제거하면 유니온과 파인드가 둘다 O(1)에 되는 놀라운 결과가 나온다. 
결국 문제를 푸는데 걸리는 시간은 O(n)이면 충분하였다.</content><author><name>이대겸</name></author><category term="Til" /><summary type="html">SVD(Singular value decomposition)과 pca가 기억에 남는다. SVD는 행렬 A를 U : 회전행렬, D : 대각행렬, V : 회전행렬 이 셋의 곱으로 즉 A = UDV 꼴로 분해하는 것이다. 수학과에서 배우는 선대에선 주로 operator의 관점에서 다룰 때가 많았고 1학년 때 배운 공대생을 위한 선대 수업은 워낙 대충 들어서 이런걸 배웠는지 잘 기억이 나지 않는다. n by n 행렬의 jordan form에 1들이 덕지덕지 붙어있던걸 생각하면 대각행렬로 분해된다는 것이 얼마나 깔끔한가. 지금 강의를 보충할 겸 인터넷에서 적당한 numerical linear algebra 책을 보고 있는데 마침 초반에 SVD에 관한 증명이 있었다. 간략하게 적으면 ATA가 symmetric이고 positive semi definite인 점을 이용하여 orthonormal한 eigenvector vi들을 뽑은 뒤 AV가 UD 꼴임을 직접 보였다. 한편 컴퓨터로 분해를 구현하는건 책의 뒷부분에 나와있다고 하는데 이 과정에 ATA의 eigenvector들을 뽑는 과정이 필요한걸 어떤식으로 회피할지 혹은 구할지 기대된다. pca는 뭘 하고자 하는지는 알겠는데 어째서 그런게 가능하게 되는지는 아직 이해가 가지 않는다. 이 링크의 글이 잘 설명하고 있는 것 같아서 읽어 보고 있다.</summary></entry><entry><title type="html">TIL 8</title><link href="http://localhost:4000/2021/TIL8" rel="alternate" type="text/html" title="TIL 8" /><published>2021-12-15T01:30:00+09:00</published><updated>2021-12-15T01:30:00+09:00</updated><id>http://localhost:4000/2021/TIL8</id><content type="html" xml:base="http://localhost:4000/2021/TIL8">&lt;p&gt;SVD(Singular value decomposition)과 pca가 기억에 남는다.&lt;br /&gt;
SVD는 행렬 A를 U : 회전행렬, D : 대각행렬, V : 회전행렬 이 셋의 곱으로 즉 A = UDV 꼴로 분해하는 것이다. 
수학과에서 배우는 선대에선 주로 operator의 관점에서 다룰 때가 많았고 1학년 때 배운 공대생을 위한 선대 수업은 워낙 대충 들어서 
이런걸 배웠는지 잘 기억이 나지 않는다.&lt;br /&gt;
n by n 행렬의 jordan form에 1들이 덕지덕지 붙어있던걸 생각하면 대각행렬로 분해된다는 것이 얼마나 깔끔한가. 지금 강의를 보충할 겸 
인터넷에서 적당한 numerical linear algebra 책을 보고 있는데 마침 초반에 SVD에 관한 증명이 있었다. 간략하게 적으면 A&lt;sup&gt;T&lt;/sup&gt;A가 
symmetric이고 positive semi definite인 점을 이용하여 orthonormal한 eigenvector v&lt;sub&gt;i&lt;/sub&gt;들을 뽑은 뒤 
AV가 UD 꼴임을 직접 보였다. 한편 컴퓨터로 분해를 구현하는건 책의 뒷부분에 나와있다고 하는데 이 과정에 A&lt;sup&gt;T&lt;/sup&gt;A의 eigenvector들을 뽑는 과정이 필요한걸 
어떤식으로 회피할지 혹은 구할지 기대된다.&lt;br /&gt;
pca는 뭘 하고자 하는지는 알겠는데 어째서 그런게 가능하게 되는지는 아직 이해가 가지 않는다. &lt;a href=&quot;https://angeloyeo.github.io/2019/07/27/PCA.html&quot;&gt; 이 링크&lt;/a&gt;의 글이 
잘 설명하고 있는 것 같아서 읽어 보고 있다.&lt;/p&gt;

&lt;p&gt;그 외에 유니온파인드 알고리즘에 대해 공부하였다. 열흘 전에 &lt;a href=&quot;https://www.acmicpc.net/problem/2463&quot;&gt;백준 2463번&lt;/a&gt;을 풀면서 
이런 알고리즘이 존재한다는 건 알았는데 일단 풀 당시에는 혼자서 풀어보고자 이것저것 시도해보았다. 중간에 유니온파인드의 핵심인 트리구조도 시도는 해보았으나 
O(n^2)의 벽에 부딪혀 결국 선형 자료구조를 사용해 O(nlogn)으로 풀긴 하였지만 시간은 매우 느렸다. 알고리즘을 보니 일단 트리를 합칠 때 간단하게 높이를 기준으로 
비교하여 find에 걸리는 시간을 O(logn)까지 줄일 수 있었다. 그런데 거기서 DP와 비슷한 방식으로 중복을 제거하면 유니온과 파인드가 둘다 O(1)에 되는 놀라운 결과가 나온다. 
결국 문제를 푸는데 걸리는 시간은 O(n)이면 충분하였다.&lt;/p&gt;</content><author><name>이대겸</name></author><category term="Til" /><summary type="html">SVD(Singular value decomposition)과 pca가 기억에 남는다. SVD는 행렬 A를 U : 회전행렬, D : 대각행렬, V : 회전행렬 이 셋의 곱으로 즉 A = UDV 꼴로 분해하는 것이다. 수학과에서 배우는 선대에선 주로 operator의 관점에서 다룰 때가 많았고 1학년 때 배운 공대생을 위한 선대 수업은 워낙 대충 들어서 이런걸 배웠는지 잘 기억이 나지 않는다. n by n 행렬의 jordan form에 1들이 덕지덕지 붙어있던걸 생각하면 대각행렬로 분해된다는 것이 얼마나 깔끔한가. 지금 강의를 보충할 겸 인터넷에서 적당한 numerical linear algebra 책을 보고 있는데 마침 초반에 SVD에 관한 증명이 있었다. 간략하게 적으면 ATA가 symmetric이고 positive semi definite인 점을 이용하여 orthonormal한 eigenvector vi들을 뽑은 뒤 AV가 UD 꼴임을 직접 보였다. 한편 컴퓨터로 분해를 구현하는건 책의 뒷부분에 나와있다고 하는데 이 과정에 ATA의 eigenvector들을 뽑는 과정이 필요한걸 어떤식으로 회피할지 혹은 구할지 기대된다. pca는 뭘 하고자 하는지는 알겠는데 어째서 그런게 가능하게 되는지는 아직 이해가 가지 않는다. 이 링크의 글이 잘 설명하고 있는 것 같아서 읽어 보고 있다.</summary></entry><entry><title type="html">TIL 7</title><link href="http://localhost:4000/2021/TIL7.markdown" rel="alternate" type="text/html" title="TIL 7" /><published>2021-12-15T01:30:00+09:00</published><updated>2021-12-15T01:30:00+09:00</updated><id>http://localhost:4000/2021/TIL7.markdown</id><content type="html" xml:base="http://localhost:4000/2021/TIL7.markdown">강의에서 선형대수를 다루다 보니 그에 관해 조금 공부를 하였다. numerical stability나 LU분해의 time complexity 등등.. 
그러나 아직 원하는 만큼 정리되지 않아 다음에 올리도록 하겠다. 

한편 오늘은 트립을 이해하기 위해 시간을 조금 써보았다. 종만북에 나오는 트립의 구현 그 중에서 트리 split 부분은 다음과 같다.
~~~C++
NodePair split(Node* root, KeyType key) {
	if (root == NULL) return NodePair(NULL, NULL);
	if (root-&gt;key &lt; key) {
		NodePair rs = split(root-&gt;right, key);
		root-&gt;setRight(rs.first);
		return NodePair(root, rs.second);
	}
	NodePair ls = split(root-&gt;left, key);
	root-&gt;setLeft(ls.second);
	return NodePair(ls.first, root);
}
~~~
그리고 이 재귀적인 함수가 어떻게 트리를 쪼개고 합치는지 파악이 안되서 예를 들어서 직접 표현해보았다.
![tree_split](/assets/img/posts/Treap_image_1.jpg)
![tree_split2](/img/Treap_image_2.jpg)

한 번 과정을 직접 따라가 보니 이해가 되었는데, 일단 재귀를 하면서 깊이 들어갈 때 루트를 보고 key와 비교해서 key보다 무조건 큰 트리 또는 
key보다 무조건 작은 트리들을 분리해서 덜어둔다. 그리고 아직 key와의 비교가 불분명한 서브트리를 다시 들어가서 비교하고 분리하고.. 이렇게 어떤 리프 노드까지 도달한다. 
그럼 이제 pair&lt;Node, Node&gt; 를 리턴하면서 돌아가는데 key보다 큰 값들이 모인 서브트리의 루트를 pair.second에, 작은 값들이 모인 서브트리의 루트를 
pair.first에 두면서 미리 덜어내놓았던 트리와 만났을 때 그 트리의 오른쪽이 비어있으면(작은 서브트리이므로) pair.first를 붙이고 왼쪽이 붙어있으면(큰 서브트리이므로) pair.second를 붙이면서 
다시 pair를 갱신해서 리턴하고.. 이렇게 반복해서 돌아오면 우리가 원하는 treap이 완성된다. 이 과정을 insert함수까지 포함해서 코드 20줄가량으로 표현하다니 참 대단하다. 
종만북에서 본 내용중 스택을 이용한 울타리자르기와 쌍벽을 이룰만큼 어려웠던 것 같다.</content><author><name>이대겸</name></author><category term="Til" /><category term="Algorithm" /><category term="Treap" /><summary type="html">강의에서 선형대수를 다루다 보니 그에 관해 조금 공부를 하였다. numerical stability나 LU분해의 time complexity 등등.. 그러나 아직 원하는 만큼 정리되지 않아 다음에 올리도록 하겠다.</summary></entry><entry><title type="html">TIL 6</title><link href="http://localhost:4000/2021/TIL6" rel="alternate" type="text/html" title="TIL 6" /><published>2021-12-14T00:10:00+09:00</published><updated>2021-12-14T00:10:00+09:00</updated><id>http://localhost:4000/2021/TIL6</id><content type="html" xml:base="http://localhost:4000/2021/TIL6">&lt;p&gt;Jupyter notebook의 기본적인 사용법을 익혔다. Jupyter notebook은 cell 단위로 실행되며 실행하는 단축키는 
shift + enter 이다. esc를 누르면 해당셀의 테두리가 파랗게 되면서 명령모드로 진입하는데 이 때 할 수 있는 명령으로 다음이 있다.&lt;/p&gt;

&lt;p&gt;m : markdown 형식의 주석 입력&lt;br /&gt;
a(above) : 현재 셀 위에 새로운 cell 추가&lt;br /&gt;
b(below) : 현재 셀 아래에 새로운 cell 추가&lt;br /&gt;
dd(delete) : 현재 셀 삭제&lt;/p&gt;

&lt;p&gt;한편 jupyter notebook에 작성하는 주석의 형식도 git에 작성하는 문서의 형식과 똑같은 markdown이여서 
&lt;strong&gt;오늘&lt;/strong&gt; &lt;em&gt;배운&lt;/em&gt; &lt;del&gt;것들을&lt;/del&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Git Blog에서&lt;/li&gt;
  &lt;li&gt;전부&lt;/li&gt;
  &lt;li&gt;활용 
가능하다!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그 외에 numpy의 활용을 조금 맛보기.&lt;br /&gt;
&lt;strong&gt;numpy.array&lt;/strong&gt; : numpy가 가진 고유의 배열을 만들어 주며, 생성자로 리스트를 받을 수 있다.&lt;br /&gt;
&lt;strong&gt;numpy.arange&lt;/strong&gt; : range를 통해 만드는 리스트와 같은 numpy array를 만들어 준다.&lt;br /&gt;
&lt;strong&gt;array.shape(= numpy.shape(array))&lt;/strong&gt; : n차원 행렬이 a_1*a_2*…*a_m 형태일 때 
튜플 (a_1, a_2, …, a_m)  을 리턴해준다. 1*m 꼴일 땐 (m, ) 으로 리턴한다.&lt;br /&gt;
&lt;strong&gt;numpy.linalg.inv(array)&lt;/strong&gt; : array의 역행렬을 구해준다.
&lt;strong&gt;numpy.linalg.norm(array, ord)&lt;/strong&gt; : array 만 입력했을 땐 euclidean norm을&lt;br /&gt;
리턴해주는데, ord에 따라서 절대값의 합이나 가장 작은 eigen value, 
일반적인 p-norm등으로 리턴해준다.&lt;br /&gt;
&lt;strong&gt;operator@(array, array)&lt;/strong&gt; : 두 array의 행렬곱을 A @ B로 표현하게 해주는 연산자이다.&lt;/p&gt;</content><author><name>이대겸</name></author><category term="Til" /><category term="Jupyter Notebook" /><category term="Markdown" /><category term="Numpy" /><summary type="html">Jupyter notebook의 기본적인 사용법을 익혔다. Jupyter notebook은 cell 단위로 실행되며 실행하는 단축키는 shift + enter 이다. esc를 누르면 해당셀의 테두리가 파랗게 되면서 명령모드로 진입하는데 이 때 할 수 있는 명령으로 다음이 있다.</summary></entry><entry><title type="html">TIL 6</title><link href="http://localhost:4000/2021/TIL6.markdown" rel="alternate" type="text/html" title="TIL 6" /><published>2021-12-14T00:10:00+09:00</published><updated>2021-12-14T00:10:00+09:00</updated><id>http://localhost:4000/2021/TIL6.markdown</id><content type="html" xml:base="http://localhost:4000/2021/TIL6.markdown">Jupyter notebook의 기본적인 사용법을 익혔다. Jupyter notebook은 cell 단위로 실행되며 실행하는 단축키는 
shift + enter 이다. esc를 누르면 해당셀의 테두리가 파랗게 되면서 명령모드로 진입하는데 이 때 할 수 있는 명령으로 다음이 있다.

m : markdown 형식의 주석 입력  
a(above) : 현재 셀 위에 새로운 cell 추가  
b(below) : 현재 셀 아래에 새로운 cell 추가  
dd(delete) : 현재 셀 삭제  

한편 jupyter notebook에 작성하는 주석의 형식도 git에 작성하는 문서의 형식과 똑같은 markdown이여서 
**오늘** *배운* ~~것들을~~ 
- Git Blog에서
- 전부
- 활용 
가능하다!

그 외에 numpy의 활용을 조금 맛보기.  
**numpy.array** : numpy가 가진 고유의 배열을 만들어 주며, 생성자로 리스트를 받을 수 있다.  
**numpy.arange** : range를 통해 만드는 리스트와 같은 numpy array를 만들어 준다.  
**array.shape(= numpy.shape(array))** : n차원 행렬이 a_1\*a\_2\*...\*a\_m 형태일 때 
튜플 (a\_1, a\_2, ..., a\_m)  을 리턴해준다. 1*m 꼴일 땐 (m, ) 으로 리턴한다.  
**numpy.linalg.inv(array)** : array의 역행렬을 구해준다.
**numpy.linalg.norm(array, ord)** : array 만 입력했을 땐 euclidean norm을  
리턴해주는데, ord에 따라서 절대값의 합이나 가장 작은 eigen value, 
일반적인 p-norm등으로 리턴해준다.  
** operator@(array, array) ** : 두 array의 행렬곱을 A @ B로 표현하게 해주는 연산자이다.</content><author><name>이대겸</name></author><category term="Til" /><category term="Jupyter Notebook" /><category term="Markdown" /><category term="Numpy" /><summary type="html">Jupyter notebook의 기본적인 사용법을 익혔다. Jupyter notebook은 cell 단위로 실행되며 실행하는 단축키는 shift + enter 이다. esc를 누르면 해당셀의 테두리가 파랗게 되면서 명령모드로 진입하는데 이 때 할 수 있는 명령으로 다음이 있다.</summary></entry><entry><title type="html">TIL 5</title><link href="http://localhost:4000/2021/TIL5" rel="alternate" type="text/html" title="TIL 5" /><published>2021-12-13T00:05:00+09:00</published><updated>2021-12-13T00:05:00+09:00</updated><id>http://localhost:4000/2021/TIL5</id><content type="html" xml:base="http://localhost:4000/2021/TIL5">&lt;p&gt;일요일이 늘 그렇듯 개인 사정으로 크게 공부는 못했으나.. 일단 오늘도 백준 2문제를 푸는 걸로 
이전에 얻었던 8일 연속 문제 해결 뱃지와 동일한 기록에 도달하였다. 목표는 현재 AI 데브코스를 듣는 기간과 거의 비슷한 128일 뱃지를 얻는 것!&lt;/p&gt;

&lt;p&gt;그 외에는 이 블로그 관리를 위해 jekyll 공식 문서를 조금 읽어보았다.&lt;/p&gt;

&lt;p&gt;front matter는&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;---
layout: post
read_time: true
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;이런 것으로 두 줄의 ‘—’ 사이에 변수이름:값 형식으로 나열하면 되는데 이는 yaml에서 사용되는 데이터 작성을 위한 포맷이라고 한다.&lt;/p&gt;

&lt;p&gt;page는 자기소개 페이지같은 곳에 사용하는데 문제는 새로운 page를 만들었을 때 메뉴에 추가하는 방법을 아직 못 찾았다. 
post를 좀 더 정리하기 위해서도 메뉴를 조정해야 할 것 같은데 그 방법을 소개해주는 글들과 사용하는 theme가 다르니 
가리키는 위치에 필요한 파일이 없다거나 하는 경우로 무작정 따라할 수가 없다. 그게 이 문서를 읽고있는 이유기도 하다.&lt;/p&gt;

&lt;p&gt;한편 include에 대한 이해는 큰 도움이 되었다. 이 블로그의 내용이 들어있는 git 저장소에는 다양한 html 파일들이 있는데, 
예를 들어 _layout 폴더의 home-page.html 파일에서 {% include search.html %} 라는 표현이 있으면 
home-page layout을 사용할 때(위의 front matter 부분에 layout: home-page를 쓰면 된다.) 
_includes 폴더에서 search.html파일을 불러와 화면상에 표시해준다. 이걸로 post에서 필요없는 news letter를 드디어 
삭제할 수 있었다.&lt;/p&gt;</content><author><name>이대겸</name></author><category term="Til" /><category term="jekyll" /><category term="blog" /><summary type="html">일요일이 늘 그렇듯 개인 사정으로 크게 공부는 못했으나.. 일단 오늘도 백준 2문제를 푸는 걸로 이전에 얻었던 8일 연속 문제 해결 뱃지와 동일한 기록에 도달하였다. 목표는 현재 AI 데브코스를 듣는 기간과 거의 비슷한 128일 뱃지를 얻는 것!</summary></entry><entry><title type="html">TIL 4</title><link href="http://localhost:4000/2021/TIL4" rel="alternate" type="text/html" title="TIL 4" /><published>2021-12-12T00:25:00+09:00</published><updated>2021-12-12T00:25:00+09:00</updated><id>http://localhost:4000/2021/TIL4</id><content type="html" xml:base="http://localhost:4000/2021/TIL4">&lt;p&gt;종만북을 보면서 알고리즘 공부를 하였다.
balanced tree중 구현하기 쉽다는 트립과 세그먼트 트리, 그리고 펜윅 트리를 배웠다.&lt;/p&gt;

&lt;p&gt;트립은 노드를 좌우로 크기에 따라 정렬하는 것 뿐만이 아니라 각 노드에 난수로 우선순위를 부여하여
 위에서 아래로 그 우선순위에 따라서 또 배열한다. 소수 판별에 난수를 사용하는 알고리즘을 본 적은 있지만
자료구조에 난수라니 대단한 아이디어다.
그런데 이게 노드를 추가하고 삭제하는 과정이 영 이해가 안가서.. 추후에 더 이해한 후에 따로 포스트를 해 봐야겠다.&lt;/p&gt;

&lt;p&gt;세그먼트 트리는 어떤 배열이 있을 때 그 구간을 반으로 쪼개서 좌우 자식노드로 붙이고 다시 반쪽 구간들을 반토막 내서
자식의 자식으로 붙이고.. 이렇게 해서 log n 높이의 트리를 만드는 것이다. 그리고 구하고자 하는 값을 트리의 노드들이 나타내는
구간들에 대해 미리 구해놓고, 임의의 [a:b]에 대해 그 구간들을 합병하여 결과값을 구한다. 이 방법의 장점으로는 한번 트리의 노드들에 값을
구해 놓으면 여러 [a:b]들에 대해 O(log n)의 시간으로 결과값을 구하게 해준다는 점이 있고, 배열에 어떤 값이 변하더라도 그 변화를
결과에 반영하는데 O(log n)의 시간밖에 걸리지 않는 다는 점 또한 있다.&lt;/p&gt;

&lt;p&gt;펜윅 트리는 세그먼트 트리의 특수한 형태인데, 세그먼트 트리를 사용해 구간합을 구하기 위해 필요없는 정보는 전부 삭제한 것이다.
 그런데 그 형태가 어찌나 정교한지, 비트마스킹으로 인덱스를 옮겨다니는건 기가 막힌다. 구간합을 구하는 건 그냥 부분합을 구하는걸로 
 충분하지 않은가 생각할 수 있지만, 펜윅 트리도 세그먼트 트리와 마찬가지로 배열의 값이 변경됐을 때 그걸 반영하는데 O(log n)의 
 시간밖에 걸리지 않는다는 장점이 있다.&lt;/p&gt;</content><author><name>이대겸</name></author><category term="Til" /><summary type="html">종만북을 보면서 알고리즘 공부를 하였다. balanced tree중 구현하기 쉽다는 트립과 세그먼트 트리, 그리고 펜윅 트리를 배웠다.</summary></entry></feed>
<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-12-12T01:03:34+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Hello</title><subtitle>for record</subtitle><author><name>이대겸</name></author><entry><title type="html">TIL 4</title><link href="http://localhost:4000/TIL4.html" rel="alternate" type="text/html" title="TIL 4" /><published>2021-12-12T00:25:00+09:00</published><updated>2021-12-12T00:25:00+09:00</updated><id>http://localhost:4000/TIL4</id><content type="html" xml:base="http://localhost:4000/TIL4.html">&lt;p&gt;종만북을 보면서 알고리즘 공부를 하였다.
balanced tree중 구현하기 쉽다는 트립과 세그먼트 트리, 그리고 펜윅 트리를 배웠다.&lt;/p&gt;

&lt;p&gt;트립은 노드를 좌우로 크기에 따라 정렬하는 것 뿐만이 아니라 각 노드에 난수로 우선순위를 부여하여
 위에서 아래로 그 우선순위에 따라서 또 배열한다. 소수 판별에 난수를 사용하는 알고리즘을 본 적은 있지만
자료구조에 난수라니 대단한 아이디어다.
그런데 이게 노드를 추가하고 삭제하는 과정이 영 이해가 안가서.. 추후에 더 이해한 후에 따로 포스트를 해 봐야겠다.&lt;/p&gt;

&lt;p&gt;세그먼트 트리는 어떤 배열이 있을 때 그 구간을 반으로 쪼개서 좌우 자식노드로 붙이고 다시 반쪽 구간들을 반토막 내서
자식의 자식으로 붙이고.. 이렇게 해서 log n 높이의 트리를 만드는 것이다. 그리고 구하고자 하는 값을 트리의 노드들이 나타내는
구간들에 대해 미리 구해놓고, 임의의 [a:b]에 대해 그 구간들을 합병하여 결과값을 구한다. 이 방법의 장점으로는 한번 트리의 노드들에 값을
구해 놓으면 여러 [a:b]들에 대해 O(log n)의 시간으로 결과값을 구하게 해준다는 점이 있고, 배열에 어떤 값이 변하더라도 그 변화를
결과에 반영하는데 O(log n)의 시간밖에 걸리지 않는 다는 점 또한 있다.&lt;/p&gt;

&lt;p&gt;펜윅 트리는 세그먼트 트리의 특수한 형태인데, 세그먼트 트리를 사용해 구간합을 구하기 위해 필요없는 정보는 전부 삭제한 것이다.
 그런데 그 형태가 어찌나 정교한지, 비트마스킹으로 인덱스를 옮겨다니는건 기가 막힌다. 구간합을 구하는 건 그냥 부분합을 구하는걸로 
 충분하지 않은가 생각할 수 있지만, 펜윅 트리도 세그먼트 트리와 마찬가지로 배열의 값이 변경됐을 때 그걸 반영하는데 O(log n)의 
 시간밖에 걸리지 않는다는 장점이 있다.&lt;/p&gt;</content><author><name>이대겸</name></author><category term="Til" /><summary type="html">종만북을 보면서 알고리즘 공부를 하였다. balanced tree중 구현하기 쉽다는 트립과 세그먼트 트리, 그리고 펜윅 트리를 배웠다.</summary></entry><entry><title type="html">TIL 3</title><link href="http://localhost:4000/TIL3.html" rel="alternate" type="text/html" title="TIL 3" /><published>2021-12-11T01:35:00+09:00</published><updated>2021-12-11T01:35:00+09:00</updated><id>http://localhost:4000/TIL3</id><content type="html" xml:base="http://localhost:4000/TIL3.html">&lt;p&gt;오늘 강의에서 dfs를 stack을 이용해서 구현하는 걸 보았다. 정점 탐색이 아니라 간선 탐색이라 조금은 다르긴 하겠지만 
일반적인 dfs의 경우에도 비슷하게 구현할 수 있을 것이다. 사실 함수 호출이 다 스택 영역에서 이루어 지는 만큼 그를 응용하면
구현할 수 있는 건 당연하겠지만, 생각했던 것보다 훨씬 간단해서 알아두면 활용할 데가 많을 것 같았다. 안그래도 
개인적으로 재귀에 대해 구현은 보기 좋으나 비효율적인 면이 있어 싫어하는데 앞으로 재귀 문제에선 전부 stack구현을 시도해봐야겠다.&lt;/p&gt;

&lt;p&gt;한편 이번 강의에서 하필 stack을 사용한 이유는 정점의 갯수가 최대 1만개까지 가기 때문으로 보인다.
파이썬은 재귀 횟수에 1000의 제한이 있고, C++은 Visual studio 기준으로 1mb의 stack memory 제한이 있다.
이를 해제하는 방법은 있으나, 제한에는 나름의 이유가 있을 것이다. 이에 관한 내용을 &lt;a href=&quot;https://stackoverflow.com/questions/10482974/why-is-stack-memory-size-so-limited&quot;&gt;
다음 스택 오버플로우 링크 &lt;/a&gt;에서 확인할 수 있었다.&lt;/p&gt;

&lt;p&gt;첫번째 답변에선 “32bit 프로그램은 2gb의 가상공간을 가질 수 있고 이 때 stack size가 2mb라면 1024개의 threads를 가질 수
있다(각 thread는 thread stack이라고 부르는 고유의 stack을 가진다고 한다). web server 같은 경우엔 stack size를
100mb까지 늘리고 20개의 thread만 가져도 충분할 수 있지만, 아주 간단한 gui 프로그램이라도 이는 부족하다” 고 하였으며&lt;/p&gt;

&lt;p&gt;두번째 답변에선 “C 또는 C++에서 stack overflow가 일어나는 경우는 거의 에러가 원인이기 때문에, 제한된 stack size는 
에러 감지 및 방지를 위해 사용된다” 고 하였다.&lt;/p&gt;

&lt;p&gt;둘 다 꽤나 역사가 담긴 답변이다.&lt;/p&gt;</content><author><name>이대겸</name></author><category term="Til" /><summary type="html">오늘 강의에서 dfs를 stack을 이용해서 구현하는 걸 보았다. 정점 탐색이 아니라 간선 탐색이라 조금은 다르긴 하겠지만 일반적인 dfs의 경우에도 비슷하게 구현할 수 있을 것이다. 사실 함수 호출이 다 스택 영역에서 이루어 지는 만큼 그를 응용하면 구현할 수 있는 건 당연하겠지만, 생각했던 것보다 훨씬 간단해서 알아두면 활용할 데가 많을 것 같았다. 안그래도 개인적으로 재귀에 대해 구현은 보기 좋으나 비효율적인 면이 있어 싫어하는데 앞으로 재귀 문제에선 전부 stack구현을 시도해봐야겠다.</summary></entry><entry><title type="html">TIL 2</title><link href="http://localhost:4000/TIL2.html" rel="alternate" type="text/html" title="TIL 2" /><published>2021-12-09T23:55:00+09:00</published><updated>2021-12-09T23:55:00+09:00</updated><id>http://localhost:4000/TIL2</id><content type="html" xml:base="http://localhost:4000/TIL2.html">&lt;p&gt;어제 열심히 cmp_to_key로 구현했던 문제가 공교롭게도 오늘 강의에서 다루어졌다.
강의에선 깔끔한 방법으로 key를 만들어 구현해냈는데, 거기서 한 문자열을 여러번 반복해서 비교하는 테크닉을 사용하였다.
원형 문자열에 관한 문제를 풀 때도 그렇고 종종 쓰이는 듯 하다.&lt;/p&gt;

&lt;p&gt;오늘도 Git에 대해 조금 더 공부하였는데 merge와 branch에 대해 알게 되었다. 
한 branch에서 막 문서를 수정하고 다른 branch로 이동하니까 그 문서가 이전 상태 그대로 돌아가있는게 충격적이였다.
간단하게 정리해보면&lt;/p&gt;

&lt;p&gt;cd [경로] : 기준 폴더를 이동할 때 쓴다.&lt;/p&gt;

&lt;p&gt;git init : 로컬 저장소 초기화&lt;/p&gt;

&lt;p&gt;git add [파일이름 또는 경로] : 해당 파일을 인덱스에 등록. 경로내 모든파일을 add하고싶을 땐 이름 대신 ./ 을 쓰면 된다.&lt;/p&gt;

&lt;p&gt;git commit -m “메세지” : 인덱스에 등록된 변경사항을 바탕으로 현재 진행 상태를 로컬 저장소에 저장.&lt;/p&gt;

&lt;p&gt;git push [url] [branch] : 원격 저장소의 해당 branch에 지금까지 commit한 것들을 반영한다.&lt;/p&gt;

&lt;p&gt;git pull [url] [branch] : 원격 저장소의 해당 branch의 내용을 로컬 저장소로 가져온다.&lt;/p&gt;

&lt;p&gt;git status : 말 그대로 상태를 보여준다.&lt;/p&gt;

&lt;p&gt;git log (–graph) (–oneline) : 지금까지 commit 한 log들을 보여준다. 괄호안의 내용을 입력하면 간단하게 나온다.&lt;/p&gt;

&lt;p&gt;git branch : branch들을 보여준다.&lt;/p&gt;

&lt;p&gt;git branch (-d) [branch 이름] : branch를 만든다. -d를 입력하면 삭제한다.&lt;/p&gt;

&lt;p&gt;git checkout (-b) [branch 이름] : branch로 이동한다. -b를 입력하면 그 branch를 생성하며 이동한다.&lt;/p&gt;

&lt;p&gt;git merge [branch 이름] : branch를 합친다. 충돌이 발생하면 수동으로 해결해야 한다.&lt;/p&gt;

&lt;p&gt;이 정도인 것 같다. 일단 혼자서 가지고 놀만큼의 기초는 뗀 것 같고 마침 슬랙에서 한 분이 Git 공부에 관한 조언을 해 주셔서 그 부분을 봐야겠다.&lt;/p&gt;</content><author><name>이대겸</name></author><category term="Til" /><category term="Git" /><summary type="html">어제 열심히 cmp_to_key로 구현했던 문제가 공교롭게도 오늘 강의에서 다루어졌다. 강의에선 깔끔한 방법으로 key를 만들어 구현해냈는데, 거기서 한 문자열을 여러번 반복해서 비교하는 테크닉을 사용하였다. 원형 문자열에 관한 문제를 풀 때도 그렇고 종종 쓰이는 듯 하다.</summary></entry><entry><title type="html">TIL 1</title><link href="http://localhost:4000/TIL1.html" rel="alternate" type="text/html" title="TIL 1" /><published>2021-12-08T20:10:00+09:00</published><updated>2021-12-08T20:10:00+09:00</updated><id>http://localhost:4000/TIL1</id><content type="html" xml:base="http://localhost:4000/TIL1.html">&lt;p&gt;어제 오늘 동안 데브코스 강좌의 내용과 더불어 Git의 사용법에 대해 공부하였다.&lt;/p&gt;

&lt;p&gt;이제 Git에서 뭔가 기여할 때 clone 해와서 수정하고 add, commit 과정을 거쳐 push까지 하면 되는 건 알았다.&lt;/p&gt;

&lt;p&gt;강의에선 이미 알고 있던 자료구조에 대한 내용을 아주 빠르게 진행하고 있어서 복습하는 기분으로 보고 있다.&lt;/p&gt;

&lt;p&gt;도중에 나온 실습 문제에서 Python의 sort만으로 풀기엔 key parameter를 정하기 곤란한 문제가 있었다.&lt;/p&gt;

&lt;p&gt;C++이면 그냥 compare 함수를 만들어서 풀었을텐데 싶어서 찾아보니 python에도 비슷한 기능을 하는 함수가 있었다.&lt;/p&gt;

&lt;p&gt;functools 모듈의 cmp_to_key 라는 함수인데 원하는 방식으로 크기를 비교하여 그 결과를 음수, 0, 양수로 리턴하면 되는 것이다.&lt;/p&gt;

&lt;p&gt;예를 들면&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;functools&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmp_to_key&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
	
&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;l&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cmp_to_key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이와 같이 쓰면 리스트 l 을 [1, 2, 3]으로 정렬해 준다.&lt;/p&gt;</content><author><name>이대겸</name></author><summary type="html">어제 오늘 동안 데브코스 강좌의 내용과 더불어 Git의 사용법에 대해 공부하였다.</summary></entry><entry><title type="html">Github Blog 첫 글</title><link href="http://localhost:4000/Github-Blog-%EC%B2%AB-%EA%B8%80.html" rel="alternate" type="text/html" title="Github Blog 첫 글" /><published>2021-12-08T20:10:00+09:00</published><updated>2021-12-08T20:10:00+09:00</updated><id>http://localhost:4000/Github%20Blog%20%EC%B2%AB%20%EA%B8%80</id><content type="html" xml:base="http://localhost:4000/Github-Blog-%EC%B2%AB-%EA%B8%80.html">&lt;p&gt;블로그 같은건 처음 해보는데 Github로 시작하려니 어려운 점이 많네요.&lt;/p&gt;</content><author><name>이대겸</name></author><summary type="html">블로그 같은건 처음 해보는데 Github로 시작하려니 어려운 점이 많네요.</summary></entry></feed>